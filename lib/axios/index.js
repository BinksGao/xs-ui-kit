import e from"axios";import s from"qs";class a{constructor(a){this.pendingMap=new Map,this.getPendingKey=e=>{let{url:s,method:a,params:t,data:n}=e;return"string"==typeof n&&(n=JSON.parse(n)),[s,a,JSON.stringify(t),JSON.stringify(n)].join("&")},this.addPending=s=>{const a=this.getPendingKey(s);s.cancelToken=s.cancelToken||new e.CancelToken((e=>{this.pendingMap.has(a)||this.pendingMap.set(a,e)}))},this.removePending=e=>{const s=this.getPendingKey(e);if(this.pendingMap.has(s)){this.pendingMap.get(s)(s),this.pendingMap.delete(s)}},this.request=(e,a={},t={})=>{const{instance:n,axiosConfig:{requestConfig:i,timeout:o,project:r,handleResponseData:c,requestDynamicHeader:g}}=this,{config:d,headers:p={},cancelRepeatRequest:h}=t,{path:l,type:m="post"}=(({path:e,type:s},{version:a="v1",project:t})=>{let n=e;return e.includes("{projectName}")&&t&&(n=e.replace("{projectName}",t)),e.includes("{version}")&&a&&(n=e.replace("{version}",a)),{path:n,type:s}})(e,{project:r});console.log(e,r),console.log(i,"requestConfig"),console.log("====================================");const{header:u={},baseURL:f}=(({path:e},{baseDomainName:s,baseHeader:a,domainList:t})=>{let n,i;if(console.log("===================================="),console.log(s,a,t),console.log("===================================="),t)for(let s=0;s<t.length;s++){const a=t[s];if(a.serviceName){const s=a.serviceName.find((s=>"string"==typeof s?e.includes(s):e.includes(s.name)));if(s){"string"==typeof s?(i=a.headerRequest,n=a.domainName):(i=s.header||a.headerRequest,n=a.domainName);break}}}return{baseURL:n||s,header:i||a}})(e,i),b=g?g():{},R=n.request(Object.assign({url:l,baseURL:f,method:m,data:/(post|POST)/.test(m)?a:void 0,params:/(get|GET)/.test(m)?a:void 0,paramsSerializer:e=>s.stringify(e,{arrayFormat:"repeat"}),timeout:o,headers:Object.assign(Object.assign(Object.assign(Object.assign({},u),b),p),{cancelRepeatRequest:h})},d));return c?new Promise(((e,s)=>{R.then((a=>{c(a,t,this).then((s=>{e(s)})).catch((e=>{s(e)}))})).catch((e=>{s(e)}))})):R},this.onCancelRequestAll=()=>{this.pendingMap.forEach(((e,s)=>{e(s),this.pendingMap.delete(s)}))},this.axiosConfig=a,this.instance=e.create(),this.init()}init(){const{cancelRepeatRequest:s}=this.axiosConfig;this.instance.interceptors.request.use((e=>{var a;const{cancelRepeatRequest:t}=e.headers;return("boolean"!=typeof t||t)&&(void 0!==t||("boolean"!=typeof s||s)&&s)||(this.removePending(e),this.addPending(e)),(null===(a=e.headers)||void 0===a?void 0:a.cancelRepeatRequest)&&delete e.headers.cancelRepeatRequest,e})),this.instance.interceptors.response.use((e=>(this.removePending(e.config),e)),(s=>(s.config&&this.removePending(s.config),(s=>{const{message:a,response:t}=s;if(t){const{status:e,config:{url:a}}=t;switch(s.code=e,e){case 302:s.message="接口重定向了！";break;case 400:s.message="参数不正确！";break;case 401:s.message="您未登录，或者登录已经超时，请先登录！";break;case 403:s.message="您没有权限操作！";break;case 404:s.message=`请求路径不存在: ${a}`;break;case 408:s.message="请求超时！";break;case 409:s.message="系统已存在相同数据！";break;case 500:s.message="服务器内部错误！";break;case 501:s.message="服务未实现！";break;case 502:s.message="网关错误！";break;case 503:s.message="服务不可用！";break;case 504:s.message="服务暂时无法访问，请稍后再试！";break;case 505:s.message="HTTP版本不受支持！";break;default:s.message="异常问题，请联系管理员！"}}return a.includes("timeout")&&(s.message="网络请求超时！",s.code=504),a.includes("Network")&&(s.message=window.navigator.onLine?"服务端异常！":"您断网了！",s.code=-7),e.isCancel(s)?Promise.reject(s):s})(s))))}}export{a as default};
